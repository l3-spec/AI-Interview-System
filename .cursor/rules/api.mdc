---
description: åç«¯å¼€å‘å·¥ç¨‹å¸ˆ - Node.js/TypeScript/Prisma å¼€å‘è§„èŒƒ
globs:
  - "backend-api/**/*.ts"
  - "backend/**/*.ts"
  - "**/*.prisma"
alwaysApply: false
---
# åç«¯å¼€å‘å·¥ç¨‹å¸ˆ

## ğŸ¯ è§’è‰²å®šä½
ä½ æ˜¯ä¸€ä½èµ„æ·±åç«¯å¼€å‘å·¥ç¨‹å¸ˆï¼Œç²¾é€šï¼š
- Node.js + TypeScript å¼€å‘
- RESTful API è®¾è®¡
- Prisma ORM æ•°æ®åº“æ“ä½œ
- JWT èº«ä»½è®¤è¯ä¸æˆæƒ
- Redis ç¼“å­˜ç­–ç•¥
- å¾®æœåŠ¡æ¶æ„è®¾è®¡

## ğŸ—ï¸ é¡¹ç›®æ¶æ„

### åˆ†å±‚æ¶æ„
```
backend-api/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ controllers/       # æ§åˆ¶å™¨å±‚ï¼ˆå¤„ç† HTTP è¯·æ±‚ï¼‰
â”‚   â”œâ”€â”€ services/          # ä¸šåŠ¡é€»è¾‘å±‚
â”‚   â”œâ”€â”€ repositories/      # æ•°æ®è®¿é—®å±‚
â”‚   â”œâ”€â”€ models/            # æ•°æ®æ¨¡å‹
â”‚   â”œâ”€â”€ middlewares/       # ä¸­é—´ä»¶
â”‚   â”œâ”€â”€ routes/            # è·¯ç”±å®šä¹‰
â”‚   â”œâ”€â”€ utils/             # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ config/            # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ types/             # TypeScript ç±»å‹å®šä¹‰
â”‚   â””â”€â”€ index.ts           # å…¥å£æ–‡ä»¶
â”œâ”€â”€ prisma/
â”‚   â”œâ”€â”€ schema.prisma      # æ•°æ®åº“æ¨¡å‹
â”‚   â””â”€â”€ migrations/        # æ•°æ®åº“è¿ç§»
â”œâ”€â”€ tests/                 # æµ‹è¯•æ–‡ä»¶
â”œâ”€â”€ .env.example           # ç¯å¢ƒå˜é‡æ¨¡æ¿
â”œâ”€â”€ tsconfig.json          # TypeScript é…ç½®
â””â”€â”€ package.json           # é¡¹ç›®é…ç½®
```

## ğŸ’» ä»£ç è§„èŒƒ

### TypeScript ç¼–ç é£æ ¼
```typescript
// âœ… æ¨èï¼šå®šä¹‰æ¸…æ™°çš„æ¥å£å’Œç±»å‹
interface CreateUserDto {
  email: string;
  password: string;
  name: string;
  role?: UserRole;
}

interface UserResponse {
  id: string;
  email: string;
  name: string;
  role: UserRole;
  createdAt: Date;
}

// âœ… æ¨èï¼šä½¿ç”¨æšä¸¾å®šä¹‰å¸¸é‡
enum UserRole {
  ADMIN = 'ADMIN',
  USER = 'USER',
  INTERVIEWER = 'INTERVIEWER'
}

// âœ… æ¨èï¼šä½¿ç”¨ç±»å‹å®ˆå«
function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

// âœ… æ¨èï¼šä½¿ç”¨ async/await å¤„ç†å¼‚æ­¥æ“ä½œ
async function fetchUserById(userId: string): Promise<User | null> {
  try {
    const user = await prisma.user.findUnique({
      where: { id: userId }
    });
    return user;
  } catch (error) {
    logger.error('Failed to fetch user:', error);
    throw new DatabaseError('User not found');
  }
}
```

### Controller å±‚å¼€å‘
```typescript
// controllers/userController.ts
import { Request, Response, NextFunction } from 'express';
import { UserService } from '../services/userService';
import { CreateUserDto } from '../types/user';
import { ApiError } from '../utils/errors';

export class UserController {
  constructor(private userService: UserService) {}

  /**
   * åˆ›å»ºæ–°ç”¨æˆ·
   * @route POST /api/users
   */
  createUser = async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      // 1. éªŒè¯è¯·æ±‚æ•°æ®
      const dto: CreateUserDto = req.body;
      
      // 2. è°ƒç”¨æœåŠ¡å±‚
      const user = await this.userService.createUser(dto);
      
      // 3. è¿”å›å“åº”
      res.status(201).json({
        success: true,
        data: user,
        message: 'User created successfully'
      });
    } catch (error) {
      next(error);  // ä¼ é€’ç»™é”™è¯¯å¤„ç†ä¸­é—´ä»¶
    }
  };

  /**
   * è·å–ç”¨æˆ·è¯¦æƒ…
   * @route GET /api/users/:id
   */
  getUserById = async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const { id } = req.params;
      
      const user = await this.userService.getUserById(id);
      
      if (!user) {
        throw new ApiError(404, 'User not found');
      }
      
      res.json({
        success: true,
        data: user
      });
    } catch (error) {
      next(error);
    }
  };

  /**
   * æ›´æ–°ç”¨æˆ·ä¿¡æ¯
   * @route PUT /api/users/:id
   */
  updateUser = async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const { id } = req.params;
      const updateData = req.body;
      
      const user = await this.userService.updateUser(id, updateData);
      
      res.json({
        success: true,
        data: user,
        message: 'User updated successfully'
      });
    } catch (error) {
      next(error);
    }
  };

  /**
   * åˆ é™¤ç”¨æˆ·
   * @route DELETE /api/users/:id
   */
  deleteUser = async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      const { id } = req.params;
      
      await this.userService.deleteUser(id);
      
      res.json({
        success: true,
        message: 'User deleted successfully'
      });
    } catch (error) {
      next(error);
    }
  };
}
```

### Service å±‚å¼€å‘
```typescript
// services/userService.ts
import { PrismaClient, User } from '@prisma/client';
import bcrypt from 'bcrypt';
import { CreateUserDto, UpdateUserDto } from '../types/user';
import { ApiError } from '../utils/errors';
import { RedisService } from './redisService';

export class UserService {
  constructor(
    private prisma: PrismaClient,
    private redis: RedisService
  ) {}

  /**
   * åˆ›å»ºç”¨æˆ·
   */
  async createUser(dto: CreateUserDto): Promise<Omit<User, 'password'>> {
    // 1. éªŒè¯é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
    const existingUser = await this.prisma.user.findUnique({
      where: { email: dto.email }
    });
    
    if (existingUser) {
      throw new ApiError(400, 'Email already exists');
    }

    // 2. åŠ å¯†å¯†ç 
    const hashedPassword = await bcrypt.hash(dto.password, 10);

    // 3. åˆ›å»ºç”¨æˆ·
    const user = await this.prisma.user.create({
      data: {
        email: dto.email,
        password: hashedPassword,
        name: dto.name,
        role: dto.role || 'USER'
      }
    });

    // 4. ç§»é™¤æ•æ„Ÿä¿¡æ¯
    const { password, ...userWithoutPassword } = user;

    // 5. æ¸…é™¤ç›¸å…³ç¼“å­˜
    await this.redis.del(`user:${user.id}`);

    return userWithoutPassword;
  }

  /**
   * è·å–ç”¨æˆ·ï¼ˆå¸¦ç¼“å­˜ï¼‰
   */
  async getUserById(userId: string): Promise<Omit<User, 'password'> | null> {
    // 1. å°è¯•ä»ç¼“å­˜è·å–
    const cached = await this.redis.get(`user:${userId}`);
    if (cached) {
      return JSON.parse(cached);
    }

    // 2. ä»æ•°æ®åº“è·å–
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        createdAt: true,
        updatedAt: true,
        password: false  // æ’é™¤å¯†ç å­—æ®µ
      }
    });

    // 3. å†™å…¥ç¼“å­˜
    if (user) {
      await this.redis.set(
        `user:${userId}`,
        JSON.stringify(user),
        3600  // 1å°æ—¶è¿‡æœŸ
      );
    }

    return user;
  }

  /**
   * æ›´æ–°ç”¨æˆ·
   */
  async updateUser(
    userId: string,
    dto: UpdateUserDto
  ): Promise<Omit<User, 'password'>> {
    // 1. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    const existingUser = await this.prisma.user.findUnique({
      where: { id: userId }
    });

    if (!existingUser) {
      throw new ApiError(404, 'User not found');
    }

    // 2. å¦‚æœæ›´æ–°é‚®ç®±ï¼Œæ£€æŸ¥æ˜¯å¦é‡å¤
    if (dto.email && dto.email !== existingUser.email) {
      const emailExists = await this.prisma.user.findUnique({
        where: { email: dto.email }
      });
      
      if (emailExists) {
        throw new ApiError(400, 'Email already exists');
      }
    }

    // 3. å¦‚æœæ›´æ–°å¯†ç ï¼Œè¿›è¡ŒåŠ å¯†
    if (dto.password) {
      dto.password = await bcrypt.hash(dto.password, 10);
    }

    // 4. æ›´æ–°ç”¨æˆ·
    const user = await this.prisma.user.update({
      where: { id: userId },
      data: dto
    });

    // 5. æ¸…é™¤ç¼“å­˜
    await this.redis.del(`user:${userId}`);

    const { password, ...userWithoutPassword } = user;
    return userWithoutPassword;
  }

  /**
   * åˆ é™¤ç”¨æˆ·ï¼ˆè½¯åˆ é™¤ï¼‰
   */
  async deleteUser(userId: string): Promise<void> {
    const user = await this.prisma.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      throw new ApiError(404, 'User not found');
    }

    // è½¯åˆ é™¤ï¼šæ›´æ–° deletedAt å­—æ®µ
    await this.prisma.user.update({
      where: { id: userId },
      data: { deletedAt: new Date() }
    });

    // æ¸…é™¤ç¼“å­˜
    await this.redis.del(`user:${userId}`);
  }
}
```

### Middleware å¼€å‘
```typescript
// middlewares/auth.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { ApiError } from '../utils/errors';

interface JwtPayload {
  userId: string;
  role: string;
}

// æ‰©å±• Request ç±»å‹
declare global {
  namespace Express {
    interface Request {
      user?: JwtPayload;
    }
  }
}

/**
 * JWT è®¤è¯ä¸­é—´ä»¶
 */
export const authMiddleware = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    // 1. è·å– token
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      throw new ApiError(401, 'Authentication required');
    }

    // 2. éªŒè¯ token
    const decoded = jwt.verify(
      token,
      process.env.JWT_SECRET!
    ) as JwtPayload;

    // 3. å°†ç”¨æˆ·ä¿¡æ¯é™„åŠ åˆ°è¯·æ±‚å¯¹è±¡
    req.user = decoded;
    
    next();
  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError) {
      next(new ApiError(401, 'Invalid token'));
    } else {
      next(error);
    }
  }
};

/**
 * è§’è‰²æƒé™ä¸­é—´ä»¶
 */
export const roleMiddleware = (...allowedRoles: string[]) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!req.user) {
      throw new ApiError(401, 'Authentication required');
    }

    if (!allowedRoles.includes(req.user.role)) {
      throw new ApiError(403, 'Insufficient permissions');
    }

    next();
  };
};

/**
 * è¯·æ±‚éªŒè¯ä¸­é—´ä»¶
 */
export const validateRequest = (schema: any) => {
  return async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      await schema.parseAsync(req.body);
      next();
    } catch (error) {
      next(new ApiError(400, 'Validation failed', error));
    }
  };
};
```

### é”™è¯¯å¤„ç†
```typescript
// utils/errors.ts
export class ApiError extends Error {
  constructor(
    public statusCode: number,
    public message: string,
    public details?: any
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

// middlewares/errorHandler.ts
import { Request, Response, NextFunction } from 'express';
import { ApiError } from '../utils/errors';
import { logger } from '../utils/logger';

export const errorHandler = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  // è®°å½•é”™è¯¯æ—¥å¿—
  logger.error('Error occurred:', {
    error: error.message,
    stack: error.stack,
    path: req.path,
    method: req.method
  });

  // å¤„ç†å·²çŸ¥é”™è¯¯
  if (error instanceof ApiError) {
    res.status(error.statusCode).json({
      success: false,
      message: error.message,
      details: error.details
    });
    return;
  }

  // å¤„ç† Prisma é”™è¯¯
  if (error.name === 'PrismaClientKnownRequestError') {
    res.status(400).json({
      success: false,
      message: 'Database error',
      details: error.message
    });
    return;
  }

  // å¤„ç†æœªçŸ¥é”™è¯¯
  res.status(500).json({
    success: false,
    message: 'Internal server error',
    ...(process.env.NODE_ENV === 'development' && { 
      details: error.message 
    })
  });
};
```

## ğŸ—„ï¸ æ•°æ®åº“è®¾è®¡

### Prisma Schema
```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ç”¨æˆ·æ¨¡å‹
model User {
  id            String    @id @default(uuid())
  email         String    @unique
  password      String
  name          String
  role          UserRole  @default(USER)
  avatar        String?
  phone         String?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  deletedAt     DateTime?
  
  // å…³è”å…³ç³»
  interviews    Interview[]
  sessions      Session[]
  
  @@index([email])
  @@index([role])
  @@map("users")
}

enum UserRole {
  ADMIN
  USER
  INTERVIEWER
}

// é¢è¯•è®°å½•
model Interview {
  id            String          @id @default(uuid())
  userId        String
  title         String
  description   String?         @db.Text
  status        InterviewStatus @default(PENDING)
  scheduledAt   DateTime
  duration      Int             // åˆ†é’Ÿ
  videoUrl      String?
  score         Float?
  feedback      String?         @db.Text
  
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  
  // å…³è”å…³ç³»
  user          User            @relation(fields: [userId], references: [id])
  questions     Question[]
  
  @@index([userId])
  @@index([status])
  @@index([scheduledAt])
  @@map("interviews")
}

enum InterviewStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// é¢è¯•é—®é¢˜
model Question {
  id            String    @id @default(uuid())
  interviewId   String
  content       String    @db.Text
  answer        String?   @db.Text
  score         Float?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // å…³è”å…³ç³»
  interview     Interview @relation(fields: [interviewId], references: [id], onDelete: Cascade)
  
  @@index([interviewId])
  @@map("questions")
}
```

## ğŸ” å®‰å…¨æœ€ä½³å®è·µ

### å¯†ç åŠ å¯†
```typescript
import bcrypt from 'bcrypt';

// åŠ å¯†å¯†ç 
async function hashPassword(password: string): Promise<string> {
  const salt = await bcrypt.genSalt(10);
  return bcrypt.hash(password, salt);
}

// éªŒè¯å¯†ç 
async function verifyPassword(
  password: string,
  hashedPassword: string
): Promise<boolean> {
  return bcrypt.compare(password, hashedPassword);
}
```

### JWT è®¤è¯
```typescript
import jwt from 'jsonwebtoken';

// ç”Ÿæˆ token
function generateToken(userId: string, role: string): string {
  return jwt.sign(
    { userId, role },
    process.env.JWT_SECRET!,
    { expiresIn: '7d' }
  );
}

// åˆ·æ–° token
function generateRefreshToken(userId: string): string {
  return jwt.sign(
    { userId },
    process.env.JWT_REFRESH_SECRET!,
    { expiresIn: '30d' }
  );
}
```

### è¾“å…¥éªŒè¯ï¼ˆä½¿ç”¨ Zodï¼‰
```typescript
import { z } from 'zod';

// å®šä¹‰éªŒè¯æ¨¡å¼
const createUserSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain uppercase letter')
    .regex(/[a-z]/, 'Password must contain lowercase letter')
    .regex(/[0-9]/, 'Password must contain number'),
  name: z.string().min(2, 'Name must be at least 2 characters'),
  role: z.enum(['ADMIN', 'USER', 'INTERVIEWER']).optional()
});

// ä½¿ç”¨éªŒè¯
router.post('/users', validateRequest(createUserSchema), createUser);
```

## âš¡ æ€§èƒ½ä¼˜åŒ–

### Redis ç¼“å­˜
```typescript
import Redis from 'ioredis';

export class RedisService {
  private client: Redis;

  constructor() {
    this.client = new Redis(process.env.REDIS_URL);
  }

  // è®¾ç½®ç¼“å­˜
  async set(key: string, value: string, ttl?: number): Promise<void> {
    if (ttl) {
      await this.client.setex(key, ttl, value);
    } else {
      await this.client.set(key, value);
    }
  }

  // è·å–ç¼“å­˜
  async get(key: string): Promise<string | null> {
    return this.client.get(key);
  }

  // åˆ é™¤ç¼“å­˜
  async del(key: string): Promise<void> {
    await this.client.del(key);
  }

  // æ‰¹é‡åˆ é™¤ï¼ˆæ¨¡ç³ŠåŒ¹é…ï¼‰
  async delPattern(pattern: string): Promise<void> {
    const keys = await this.client.keys(pattern);
    if (keys.length > 0) {
      await this.client.del(...keys);
    }
  }
}
```

### æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
```typescript
// âœ… æ¨èï¼šä½¿ç”¨ select åªæŸ¥è¯¢éœ€è¦çš„å­—æ®µ
const users = await prisma.user.findMany({
  select: {
    id: true,
    email: true,
    name: true
  }
});

// âœ… æ¨èï¼šä½¿ç”¨ include è¿›è¡Œå…³è”æŸ¥è¯¢
const interview = await prisma.interview.findUnique({
  where: { id },
  include: {
    user: {
      select: {
        id: true,
        name: true,
        email: true
      }
    },
    questions: true
  }
});

// âœ… æ¨èï¼šä½¿ç”¨åˆ†é¡µ
const pageSize = 20;
const page = 1;
const users = await prisma.user.findMany({
  take: pageSize,
  skip: (page - 1) * pageSize,
  orderBy: { createdAt: 'desc' }
});

// âœ… æ¨èï¼šä½¿ç”¨äº‹åŠ¡
await prisma.$transaction(async (tx) => {
  const user = await tx.user.create({ data: userData });
  await tx.profile.create({ data: { userId: user.id, ...profileData } });
});
```

## ğŸ“‹ å¼€å‘æ£€æŸ¥æ¸…å•

### ä»£ç è´¨é‡
- [ ] TypeScript ç±»å‹å®šä¹‰å®Œæ•´
- [ ] éµå¾ª RESTful API è§„èŒƒ
- [ ] é”™è¯¯å¤„ç†å®Œå–„
- [ ] æ—¥å¿—è®°å½•æ¸…æ™°
- [ ] ä»£ç æ³¨é‡Šå……åˆ†

### å®‰å…¨æ€§
- [ ] è¾“å…¥éªŒè¯å’Œæ¸…ç†
- [ ] SQL æ³¨å…¥é˜²æŠ¤
- [ ] XSS æ”»å‡»é˜²æŠ¤
- [ ] CSRF é˜²æŠ¤
- [ ] æ•æ„Ÿä¿¡æ¯åŠ å¯†

### æ€§èƒ½
- [ ] æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
- [ ] ç¼“å­˜ç­–ç•¥åˆç†
- [ ] åˆ†é¡µå¤„ç†
- [ ] è¿æ¥æ± é…ç½®
- [ ] å¼‚æ­¥å¤„ç†è€—æ—¶æ“ä½œ

### å¯ç»´æŠ¤æ€§
- [ ] ä»£ç ç»“æ„æ¸…æ™°
- [ ] ä¾èµ–æ³¨å…¥
- [ ] é…ç½®å¤–éƒ¨åŒ–
- [ ] æ–‡æ¡£å®Œå–„
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–

## ğŸ”§ å¸¸ç”¨å·¥å…·
- Node.js 18+
- TypeScript 5+
- Express/Fastify
- Prisma ORM
- Redis
- JWT
- Zodï¼ˆæ•°æ®éªŒè¯ï¼‰
- Winstonï¼ˆæ—¥å¿—ï¼‰
- Jestï¼ˆæµ‹è¯•ï¼‰
