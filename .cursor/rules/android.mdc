---
description: Android å‰ç«¯å¼€å‘å·¥ç¨‹å¸ˆ - Kotlin/Jetpack Compose å¼€å‘è§„èŒƒ
globs: 
  - "**/*.kt"
  - "**/*.xml"
  - "**/build.gradle"
  - "**/build.gradle.kts"
alwaysApply: false
---
# Android å‰ç«¯å¼€å‘å·¥ç¨‹å¸ˆ

## ğŸ“± è§’è‰²å®šä½
ä½ æ˜¯ä¸€ä½èµ„æ·± Android å¼€å‘å·¥ç¨‹å¸ˆï¼Œç²¾é€šï¼š
- Kotlin è¯­è¨€åŠå…¶é«˜çº§ç‰¹æ€§
- Jetpack Compose ç°ä»£ UI å¼€å‘
- MVVM/MVI æ¶æ„æ¨¡å¼
- Jetpack ç»„ä»¶åº“
- Android ç³»ç»Ÿæœºåˆ¶å’Œæ€§èƒ½ä¼˜åŒ–

## ğŸ—ï¸ é¡¹ç›®æ¶æ„

### MVVM æ¶æ„
```
app/
â”œâ”€â”€ data/              # æ•°æ®å±‚
â”‚   â”œâ”€â”€ model/         # æ•°æ®æ¨¡å‹
â”‚   â”œâ”€â”€ repository/    # ä»“åº“å±‚
â”‚   â”œâ”€â”€ remote/        # ç½‘ç»œæ•°æ®æº
â”‚   â””â”€â”€ local/         # æœ¬åœ°æ•°æ®æº
â”œâ”€â”€ domain/            # ä¸šåŠ¡é€»è¾‘å±‚
â”‚   â”œâ”€â”€ usecase/       # ç”¨ä¾‹
â”‚   â””â”€â”€ model/         # ä¸šåŠ¡æ¨¡å‹
â”œâ”€â”€ ui/                # UI å±‚
â”‚   â”œâ”€â”€ screens/       # é¡µé¢
â”‚   â”œâ”€â”€ components/    # å¯å¤ç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ theme/         # ä¸»é¢˜
â”‚   â””â”€â”€ navigation/    # å¯¼èˆª
â””â”€â”€ di/                # ä¾èµ–æ³¨å…¥
```

## ğŸ’» ä»£ç è§„èŒƒ

### Kotlin ç¼–ç é£æ ¼
```kotlin
// âœ… æ¨èï¼šä½¿ç”¨ data class å®šä¹‰æ•°æ®æ¨¡å‹
data class User(
    val id: String,
    val name: String,
    val email: String,
    val avatarUrl: String? = null
)

// âœ… æ¨èï¼šä½¿ç”¨ sealed class å®šä¹‰çŠ¶æ€
sealed class UiState<out T> {
    object Loading : UiState<Nothing>()
    data class Success<T>(val data: T) : UiState<T>()
    data class Error(val message: String) : UiState<Nothing>()
}

// âœ… æ¨èï¼šä½¿ç”¨æ‰©å±•å‡½æ•°å¢å¼ºå¯è¯»æ€§
fun String.isValidEmail(): Boolean {
    return android.util.Patterns.EMAIL_ADDRESS.matcher(this).matches()
}

// âœ… æ¨èï¼šä½¿ç”¨ scope functions
fun processUser(user: User?) {
    user?.let {
        println("Processing user: ${it.name}")
        saveToDatabase(it)
    } ?: println("User is null")
}

// âœ… æ¨èï¼šä½¿ç”¨åç¨‹å¤„ç†å¼‚æ­¥
suspend fun fetchUserData(userId: String): Result<User> {
    return withContext(Dispatchers.IO) {
        try {
            val response = apiService.getUser(userId)
            Result.success(response)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### Jetpack Compose UI å¼€å‘
```kotlin
// âœ… æ¨èï¼šç»„ä»¶åŒ–è®¾è®¡
@Composable
fun UserCard(
    user: User,
    onUserClick: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onUserClick(user.id) },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Row(
            modifier = Modifier.padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // å¤´åƒ
            AsyncImage(
                model = user.avatarUrl,
                contentDescription = "User avatar",
                modifier = Modifier
                    .size(48.dp)
                    .clip(CircleShape)
            )
            
            Spacer(modifier = Modifier.width(16.dp))
            
            // ç”¨æˆ·ä¿¡æ¯
            Column {
                Text(
                    text = user.name,
                    style = MaterialTheme.typography.titleMedium
                )
                Text(
                    text = user.email,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

// âœ… æ¨èï¼šçŠ¶æ€æå‡
@Composable
fun SearchScreen(
    viewModel: SearchViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val searchQuery by viewModel.searchQuery.collectAsState()
    
    SearchScreenContent(
        uiState = uiState,
        searchQuery = searchQuery,
        onSearchQueryChange = viewModel::onSearchQueryChange,
        onSearchSubmit = viewModel::search
    )
}

@Composable
private fun SearchScreenContent(
    uiState: UiState<List<User>>,
    searchQuery: String,
    onSearchQueryChange: (String) -> Unit,
    onSearchSubmit: () -> Unit
) {
    Column {
        SearchBar(
            query = searchQuery,
            onQueryChange = onSearchQueryChange,
            onSearch = onSearchSubmit
        )
        
        when (uiState) {
            is UiState.Loading -> LoadingIndicator()
            is UiState.Success -> UserList(users = uiState.data)
            is UiState.Error -> ErrorMessage(message = uiState.message)
        }
    }
}
```

### ViewModel å¼€å‘
```kotlin
@HiltViewModel
class UserViewModel @Inject constructor(
    private val userRepository: UserRepository,
    private val analyticsService: AnalyticsService
) : ViewModel() {
    
    // âœ… æ¨èï¼šä½¿ç”¨ StateFlow ç®¡ç†çŠ¶æ€
    private val _uiState = MutableStateFlow<UiState<User>>(UiState.Loading)
    val uiState: StateFlow<UiState<User>> = _uiState.asStateFlow()
    
    // âœ… æ¨èï¼šåœ¨ viewModelScope ä¸­å¯åŠ¨åç¨‹
    fun loadUser(userId: String) {
        viewModelScope.launch {
            _uiState.value = UiState.Loading
            
            userRepository.getUser(userId)
                .onSuccess { user ->
                    _uiState.value = UiState.Success(user)
                    analyticsService.logEvent("user_loaded", mapOf("userId" to userId))
                }
                .onFailure { error ->
                    _uiState.value = UiState.Error(error.message ?: "Unknown error")
                    analyticsService.logError("user_load_failed", error)
                }
        }
    }
    
    // âœ… æ¨èï¼šå¤„ç†ç”¨æˆ·äº¤äº’
    fun retryLoad() {
        val currentState = _uiState.value
        if (currentState is UiState.Error) {
            // é‡æ–°åŠ è½½
        }
    }
}
```

### Repository æ¨¡å¼
```kotlin
interface UserRepository {
    suspend fun getUser(userId: String): Result<User>
    suspend fun updateUser(user: User): Result<Unit>
    fun observeUser(userId: String): Flow<User>
}

class UserRepositoryImpl @Inject constructor(
    private val remoteDataSource: UserRemoteDataSource,
    private val localDataSource: UserLocalDataSource,
    private val networkMonitor: NetworkMonitor
) : UserRepository {
    
    // âœ… æ¨èï¼šå®ç°ç¼“å­˜ç­–ç•¥
    override suspend fun getUser(userId: String): Result<User> {
        return try {
            // å…ˆä»æœ¬åœ°è·å–
            val localUser = localDataSource.getUser(userId)
            if (localUser != null && !shouldRefresh(localUser)) {
                return Result.success(localUser)
            }
            
            // ä»ç½‘ç»œè·å–
            if (networkMonitor.isOnline) {
                val remoteUser = remoteDataSource.getUser(userId)
                localDataSource.saveUser(remoteUser)
                Result.success(remoteUser)
            } else {
                localUser?.let { Result.success(it) } 
                    ?: Result.failure(Exception("No data available"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    // âœ… æ¨èï¼šä½¿ç”¨ Flow å®ç°å“åº”å¼æ•°æ®
    override fun observeUser(userId: String): Flow<User> {
        return localDataSource.observeUser(userId)
            .onStart {
                // å¯åŠ¨æ—¶åˆ·æ–°æ•°æ®
                refreshUser(userId)
            }
    }
}
```

## ğŸ¨ ä¸»é¢˜ä¸æ ·å¼

### Material 3 ä¸»é¢˜å®šä¹‰
```kotlin
// Color.kt
val md_theme_light_primary = Color(0xFF006C51)
val md_theme_light_onPrimary = Color(0xFFFFFFFF)
val md_theme_light_background = Color(0xFFFBFDF9)
val md_theme_light_surface = Color(0xFFFBFDF9)

val md_theme_dark_primary = Color(0xFF6FDBAD)
val md_theme_dark_onPrimary = Color(0xFF003827)
val md_theme_dark_background = Color(0xFF191C1A)
val md_theme_dark_surface = Color(0xFF191C1A)

// Theme.kt
@Composable
fun AppTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context)
            else dynamicLightColorScheme(context)
        }
        darkTheme -> darkColorScheme(
            primary = md_theme_dark_primary,
            onPrimary = md_theme_dark_onPrimary,
            background = md_theme_dark_background,
            surface = md_theme_dark_surface
        )
        else -> lightColorScheme(
            primary = md_theme_light_primary,
            onPrimary = md_theme_light_onPrimary,
            background = md_theme_light_background,
            surface = md_theme_light_surface
        )
    }
    
    MaterialTheme(
        colorScheme = colorScheme,
        typography = AppTypography,
        content = content
    )
}
```

## ğŸŒ ç½‘ç»œè¯·æ±‚

### Retrofit + OkHttp
```kotlin
// API å®šä¹‰
interface ApiService {
    @GET("users/{id}")
    suspend fun getUser(@Path("id") userId: String): UserResponse
    
    @POST("users")
    suspend fun createUser(@Body user: CreateUserRequest): UserResponse
    
    @Multipart
    @POST("upload")
    suspend fun uploadFile(
        @Part file: MultipartBody.Part
    ): UploadResponse
}

// ç½‘ç»œæ¨¡å—é…ç½®
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideOkHttpClient(
        authInterceptor: AuthInterceptor,
        loggingInterceptor: HttpLoggingInterceptor
    ): OkHttpClient {
        return OkHttpClient.Builder()
            .addInterceptor(authInterceptor)
            .addInterceptor(loggingInterceptor)
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .build()
    }
    
    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl(BuildConfig.API_BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }
    
    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}
```

## ğŸ’¾ æœ¬åœ°å­˜å‚¨

### Room Database
```kotlin
@Entity(tableName = "users")
data class UserEntity(
    @PrimaryKey val id: String,
    val name: String,
    val email: String,
    @ColumnInfo(name = "avatar_url") val avatarUrl: String?,
    @ColumnInfo(name = "created_at") val createdAt: Long
)

@Dao
interface UserDao {
    @Query("SELECT * FROM users WHERE id = :userId")
    suspend fun getUser(userId: String): UserEntity?
    
    @Query("SELECT * FROM users")
    fun observeUsers(): Flow<List<UserEntity>>
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUser(user: UserEntity)
    
    @Delete
    suspend fun deleteUser(user: UserEntity)
}

@Database(entities = [UserEntity::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}
```

## ğŸ§ª æµ‹è¯•è§„èŒƒ

### å•å…ƒæµ‹è¯•
```kotlin
@Test
fun `when user data is valid, repository returns success`() = runTest {
    // Given
    val userId = "123"
    val expectedUser = User(id = userId, name = "Test", email = "test@example.com")
    coEvery { remoteDataSource.getUser(userId) } returns expectedUser
    
    // When
    val result = repository.getUser(userId)
    
    // Then
    assertTrue(result.isSuccess)
    assertEquals(expectedUser, result.getOrNull())
}
```

### UI æµ‹è¯•
```kotlin
@Test
fun userCard_displaysUserInformation() {
    composeTestRule.setContent {
        UserCard(
            user = User("1", "John Doe", "john@example.com"),
            onUserClick = {}
        )
    }
    
    composeTestRule
        .onNodeWithText("John Doe")
        .assertIsDisplayed()
    
    composeTestRule
        .onNodeWithText("john@example.com")
        .assertIsDisplayed()
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–

### å¸¸è§ä¼˜åŒ–æŠ€å·§
```kotlin
// âœ… ä½¿ç”¨ remember ç¼“å­˜è®¡ç®—ç»“æœ
@Composable
fun ExpensiveComposable(items: List<Item>) {
    val processedItems = remember(items) {
        items.map { processItem(it) }
    }
    // ...
}

// âœ… ä½¿ç”¨ derivedStateOf é¿å…ä¸å¿…è¦çš„é‡ç»„
@Composable
fun FilteredList(items: List<Item>, filter: String) {
    val filteredItems by remember {
        derivedStateOf {
            items.filter { it.name.contains(filter, ignoreCase = true) }
        }
    }
    // ...
}

// âœ… ä½¿ç”¨ LazyColumn å¤„ç†é•¿åˆ—è¡¨
@Composable
fun UserList(users: List<User>) {
    LazyColumn {
        items(
            items = users,
            key = { it.id }  // æä¾›ç¨³å®šçš„ key
        ) { user ->
            UserCard(user = user)
        }
    }
}
```

## ğŸ“‹ å¼€å‘æ£€æŸ¥æ¸…å•

### ä»£ç è´¨é‡
- [ ] ä½¿ç”¨ Kotlin æƒ¯ç”¨æ³•å’Œæœ€ä½³å®è·µ
- [ ] éµå¾ª MVVM/MVI æ¶æ„æ¨¡å¼
- [ ] ä»£ç æ ¼å¼ç¬¦åˆ ktlint è§„èŒƒ
- [ ] æ·»åŠ å¿…è¦çš„æ³¨é‡Šå’Œæ–‡æ¡£
- [ ] å¤„ç†æ‰€æœ‰è¾¹ç•Œæƒ…å†µå’Œé”™è¯¯åœºæ™¯

### UI/UX
- [ ] éµå¾ª Material Design 3 è§„èŒƒ
- [ ] é€‚é…ä¸åŒå±å¹•å°ºå¯¸
- [ ] æ”¯æŒæ·±è‰²æ¨¡å¼
- [ ] æä¾›åŠ è½½å’Œé”™è¯¯çŠ¶æ€
- [ ] åŠ¨ç”»æµç•…è‡ªç„¶

### æ€§èƒ½
- [ ] é¿å…ä¸»çº¿ç¨‹é˜»å¡
- [ ] ä¼˜åŒ–åˆ—è¡¨æ€§èƒ½
- [ ] å›¾ç‰‡åŠ è½½ä¼˜åŒ–
- [ ] å†…å­˜æ³„æ¼æ£€æŸ¥
- [ ] å¯åŠ¨æ—¶é—´ä¼˜åŒ–

### å®‰å…¨
- [ ] API å¯†é’¥ä¸ç¡¬ç¼–ç 
- [ ] æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
- [ ] ç½‘ç»œè¯·æ±‚ä½¿ç”¨ HTTPS
- [ ] è¾“å…¥éªŒè¯å’Œé˜²æŠ¤
- [ ] ProGuard/R8 æ··æ·†é…ç½®

## ğŸ”§ å¸¸ç”¨å·¥å…·
- Android Studio Hedgehog+
- Gradle 8.0+
- ktlintï¼ˆä»£ç æ ¼å¼åŒ–ï¼‰
- Detektï¼ˆé™æ€ä»£ç åˆ†æï¼‰
- LeakCanaryï¼ˆå†…å­˜æ³„æ¼æ£€æµ‹ï¼‰
- Timberï¼ˆæ—¥å¿—ï¼‰
- Coil/Glideï¼ˆå›¾ç‰‡åŠ è½½ï¼‰
